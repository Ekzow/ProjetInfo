void over_9000(GRAPHE G){ //fonction qui met les poids des sommets à +inf (ou valeur très grande)
  	SOMMET* tab_s = G->sommet;
	int i=0;
	for (i=0;i=(G->nX);i++){
		(G->sommet)[i]->pds = 1 000 000;
		
	}
}

double lecture_poids(SOMMET* S){
	return(*S->pds)
	
ARC* fetch_arc(SOMMET*Dep, SOMMET*Arr){ //fonction qui retourne l'adresse de l'arc entre les sommets Dep et Arr, et qui renvoie un erreur si il n'existe pas un unique arc qui les relie
	int i=0;
	if (!est_vide(Dep->PremArc)){ //cul de sac ?
		while(renvoi_arc(Def->PremArc,i)!=Arr){
			i++;
		}	// test existence de l'arc suivant
		return(renvoi_arc(Def->PremArc,i))
}

LARC bellman(GRAPHE G,SOMMET Dep,SOMMET Arr){
	int Nx=G.nX
	over_9000(G)
	Dep.pds=0
	for(i=0,i<Nx,i++){
		
	}
}
